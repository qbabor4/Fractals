<!DOCTYPE HTML>
<!-- TODO:
    - fraktale w css
    - http://andrew-hoyer.com/experiments/fractals/
    - http://rosettacode.org/wiki/Fractal_tree#JavaScript
    - https://github.com/rembound/Mandelbrot-Fractal-HTML5/blob/master/mandelbrot-fractal.js
    - http://www.atopon.org/mandel/# (prostokątem sie zoomuje
    - Request animation frames
    window.requestAnimationFrame(main);
    - maxiterations zmieniaz dokładnosc(?)
-->
<head>
	<meta http-equiv="content-type" content="text/html" />
	<meta name="author" content="lolkittens" />
    <meta charset="utf-8" />

	<title>Untitled 1</title>
<style>
canvas {
    border: 1px solid #000;    
}

#lol {   
    width:30px;
}
</style>
</head>

<body>

<canvas id="myCanvas" width="800" height="600"> </canvas>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script>

function setCanvasVariables(){
    var canvas = $("#myCanvas")[0] //dostaje obiekt jquery a nie canvas jak jest bez [0]
    var canvasContent = canvas.getContext("2d");
    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;
    var canvasData = canvasContent.getImageData(0,0, canvasWidth, canvasHeight);
}

var offsetx = -canvasWidth/2;
var offsety = -canvasHeight/2;
var panx = -100;
var pany = 0;
var zoom = 150;

// Palette array of 256 colors
var palette = [];
    
// define values od a pixel
function drawPixel(x, y, r, g, b, a) {
    var index = ( x + y * canvasWidth) * 4  ; // data w canvasData jest jako lista, a nie macierz
    
    canvasData.data[index] = r;
    canvasData.data[index +1] = g;
    canvasData.data[index +2] = b;
    canvasData.data[index +3] = a;
}

// updatae data of pixels, so modyfications are taken in consideration
function updateCanvas() {
    canvasContent.putImageData(canvasData, 0, 0);
}


// Calculate the color of a specific pixel
function iterate(x, y, imageWidth, imageHeight, maxiterations) {
    // Convert the screen coordinate to a fractal coordinate
    var x0 = (x + offsetx + panx) / zoom;
    var y0 = (y + offsety + pany) / zoom;
    
       
    // Iteration variables
    var a = 0;
    var b = 0;
    var rx = 0;
    var ry = 0;
        
    var iterations = 0;
    while (iterations < maxiterations && (rx * rx + ry * ry <= 4)) {
        rx = a * a - b * b + x0;
        ry = 2 * a * b + y0;
            
        a = rx;
        b = ry;
        iterations++;
    }
        
    // Get palette color based on the number of iterations
    var color;
    if (iterations == maxiterations) {
        color = { r:0, g:0, b:0}; // Black
    } else {
        var index = Math.floor((iterations / (maxiterations-1)) * 255);
        color = palette[index];
    }
        
    return color;
}

function generatePalette() {
        // Calculate a gradient
        var roffset = 24;
        var goffset = 16;
        var boffset = 0;
        for (var i=0; i<256; i++) {
            palette[i] = { r:roffset, g:goffset, b:boffset};
            
            if (i < 64) {
                roffset += 3;
            } else if (i<128) {
                goffset += 3;
            } else if (i<192) {
                boffset += 3;
            }
        }
}

generatePalette();
console.log(palette);

var color = iterate(1,2, canvasWidth, canvasHeight, 250); 
console.log(color.r, color.g, color.b);
color = iterate(2,4, canvasWidth, canvasHeight, 250); 
console.log(color.r, color.g, color.b);
color = iterate(150,180, canvasWidth, canvasHeight, 250); 
console.log(color.r, color.g, color.b);


// draw pixels
for (var i = 0; i < canvasHeight + 1; i++) {
    for (var j = 0; j < canvasWidth + 1; j++){
        //drawPixel(j, i, 20,200,10,255); 
        color = iterate(j, i, canvasWidth, canvasHeight, 250);
        //console.log(color.r, color.g, color.b);
        drawPixel(j, i, color.r, color.g, color.b, 255); 
    } 
}

updateCanvas();
/*
canvasContent.moveTo(0,0);
canvasContent.lineTo(200,100);
canvasContent.moveTo(200,100);
canvasContent.lineTo(300,100);
canvasContent.stroke();
*/
</script>
</body>
</html>